/*
    QArv, a Qt interface to aravis.
    Copyright (C) 2012, 2013 Jure Varlec <jure.varlec@ad-vega.si>
                             Andrej Lajovic <andrej.lajovic@ad-vega.si>

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#ifndef QARVDECODER_H
#define QARVDECODER_H

#include <QByteArray>
#include <QString>
#include <QSize>
#include <QImage>
#include <QtPlugin>
#include "datactl/vipsutils.h"
extern "C" {
#include <libavutil/pixfmt.h>
}

#pragma GCC visibility push(default)

#ifndef ARV_PIXEL_FORMAT_MONO_8
typedef quint32 ArvPixelFormat;
#endif

//! An abstract interface of a decoder for a particular frame format and size.
/*!
 * Decoder instances are generated by plugins implementing the QArvPixelFormat
 * interface.
 */
class QArvDecoder {
public:
    virtual ~QArvDecoder() {};

    //! Decodes the given frame.
    virtual void decode(QByteArray frame) = 0;

    /*!
     * Returns the decoded frame as an OpenCv matrix. See cvType() for possible
     * types. The matrix is constant to avoid copying. It references data
     * internal to the decoder which is overwritten when decode() is called,
     * so make sure you copy the matrix or otherwise finish using it before
     * decoding another frame.
     */
    virtual const cv::Mat getCvImage() = 0;

    /*!
     * Returns the type of cv::Mat returned by getCvImage(). The decoder chooses
     * the most sensible type given the number of significant bits in input data.
     * Possible types are either CV_8U or CV_16U, with 1 or 3 channels.
     */
    virtual int cvType() = 0;

    //! Returns the pixel format supported by this decoder.
    virtual ArvPixelFormat pixelFormat() = 0;

    //! Returns an opaque token that can be used to create another instance of this decoder.
    virtual QByteArray decoderSpecification() = 0;

    /*!
     * Convenience function to convert an OpenCV image to QImage. Limited to
     * formats used by QArv (see cvType()). Returns Format_ARGB32_Premultiplied,
     * which is fast to render.
     */
    static void CV2QImage(const cv::Mat& image, QImage& out);
    static QImage CV2QImage(const cv::Mat& image);

    /*!
     * Alternative version of CV2QImage() which returns either Format_RGB888
     * or Format_Indexed8, which may be easier to use for direct pixel
     * manipulation, but are slow to render. Not recommended, for manipulation
     * cv::Mat should be used instead.
     */
    static void CV2QImage_RGB24(const cv::Mat& image, QImage& out);
    static QImage CV2QImage_RGB24(const cv::Mat& image);

    //! Uses the token returned by Decoder::decoderSpecification() to create another instance.
    static QArvDecoder* makeDecoder(QByteArray specification);

    /*!
     * Creates a decoder for the requested format and frame size.
     * Some decoders allow using a faster algorithm for decoding colors,
     * which can be (but is not neccessarily) less precise.
     */
    static QArvDecoder* makeDecoder(ArvPixelFormat, QSize size,
                                    bool fast = true);

    //! Convenience function to create a libswscale decoder, not limited to Aravis pixel formats.
    static QArvDecoder* makeSwScaleDecoder(enum AVPixelFormat fmt,
                                           QSize size,
                                           int swsFlags = 0);
};

//! Interface for the plugin to generate a decoder for a particular format.
class QArvPixelFormat {
public:
    virtual ~QArvPixelFormat() {};

    //! Returns the Aravis' name for the pixel format supported by this plugin.
    virtual ArvPixelFormat pixelFormat() = 0;

    //! Instantiates a decoder using this plugin.
    virtual QArvDecoder* makeDecoder(QSize size) = 0;

    //! Returns the list of supported pixel formats.
    static QList<ArvPixelFormat> supportedFormats();
};

Q_DECLARE_INTERFACE(QArvPixelFormat,
                    "si.ad-vega.qarv.QArvPixelFormat/0.1")

#pragma GCC visibility pop

#endif
